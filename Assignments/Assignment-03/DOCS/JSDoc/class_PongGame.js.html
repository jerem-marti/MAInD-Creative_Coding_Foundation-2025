<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: class/PongGame.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: class/PongGame.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Keyboard from './Keyboard.js';
import Touchscreen from './Touchscreen.js';
import MainLoop from '../utils/mainloop.js';
import Rectangle from './Rectangle.js';
import RectangleBouncy from './RectangleBouncy.js';
import getScreenOrientation from '../utils/screen.js';
import Audio from '../utils/audio.js';
import LineDotted from './LineDotted.js';
import Scoreboard from './Scoreboard.js';
import Text from './Text.js';
import Avatar from './Avatar.js';
import { addGameResultToHistory } from '../utils/historyManager.js';

const PADDLE_POSITION_OFFSET = 50;
const PADDLE_WIDTH = 16;
const PADDLE_HEIGHT = 80;
const PADDLE_MASS = 5;
const PADDLE_1_RELATIVE_TO = "center-right";
const PADDLE_2_RELATIVE_TO = "center-left";

const PADDLE_SPEED = 15;
const PADDLE_ACCELERATION = 10;

const BALL_SIZE = 16;
const BALL_SPEED = 5;
const BALL_BOUNCINESS = 1.1;
const BALL_MASS = 1;

const LINE_DOTTED_WIDTH = 2;
const LINE_DOTTED_DOT_LENGTH = 10;
const LINE_DOTTED_GAP_LENGTH = 10;

const SCOREBOARD_FONT = '60px Handjet, Arial';
const SCOREBOARD_COLOR = 'grey';
const SCOREBOARD_GAP = 40;

const TEXT_MARGIN = 10;

const PLAYER_AVATAR_SIZE = 28;
const PLAYER_AVATAR_POSITION = { x: TEXT_MARGIN, y: TEXT_MARGIN };
const PLAYER_AVATAR_1_RELATIVE_TO = "bottom-right";
const PLAYER_AVATAR_1_ORIENTATION = "up";
const PLAYER_AVATAR_2_RELATIVE_TO = "top-left";
const PLAYER_AVATAR_2_ORIENTATION = "down";

const PLAYER_NAME_FONT = '32px Handjet, Arial';
const PLAYER_NAME_COLOR = 'grey';
const PLAYER_NAME_POSITION = { x: TEXT_MARGIN, y: TEXT_MARGIN*2 + PLAYER_AVATAR_SIZE};
const PLAYER_NAME_1_RELATIVE_TO = "bottom-right";
const PLAYER_NAME_1_ORIENTATION = "up";
const PLAYER_NAME_2_RELATIVE_TO = "top-left";
const PLAYER_NAME_2_ORIENTATION = "down";

const WIN_SCORE = 15;

/**
 * Main game class that manages the Pong game logic, rendering, and user interactions.
 * Handles game setup, player inputs (keyboard and touchscreen), physics updates,
 * collision detection, scoring, and screen orientation changes.
 * 
 * @class PongGame
 */
export default class PongGame {
    /**
     * Creates a new PongGame instance and initializes all game components.
     * Sets up the canvas, players, paddles, balls, UI elements, and game loop.
     * 
     * @constructor
     * @param {Player} [player1="Player 1"] - The first player instance
     * @param {Player} [player2="Player 2"] - The second player instance
     * @param {string} [mode="Single Player"] - The game mode (currently unused)
     * @param {string} [player1AvatarUrlEncoded=""] - URL-encoded avatar for player 1
     * @param {string} [player2AvatarUrlEncoded=""] - URL-encoded avatar for player 2
     */
    constructor(player1 = "Player 1", player2 = "Player 2", mode = "Single Player", player1AvatarUrlEncoded = "", player2AvatarUrlEncoded = "") {
        //Players
        this.player1 = player1;
        this.player2 = player2;

        //Set players' avatars
        this.player1AvatarUrlEncoded = player1AvatarUrlEncoded;
        this.player2AvatarUrlEncoded = player2AvatarUrlEncoded;

        //Game mode
        this.mode = mode;

        //Create a canvas and set its size to the size of the window
        this.ctx = document.querySelector('canvas').getContext('2d');
        this.ctx.canvas.width = this.ctx.canvas.clientWidth;
        this.ctx.canvas.height = this.ctx.canvas.clientHeight;

        //Create a keyboard object to manage user input
        this.keyboard = new Keyboard();

        //Create a touchscreen object to manage user input
        this.touchscreen = new Touchscreen();

        //Store the orientation of the screen
        this.screenOrientation = getScreenOrientation();

        //Create paddles and ball
        let canvasSize = this.getCanvasSize();
        this.paddle1 = this.createPaddle(PADDLE_POSITION_OFFSET, 0, { relativeTo: PADDLE_1_RELATIVE_TO, canvasSize: canvasSize });
        this.paddle2 = this.createPaddle(PADDLE_POSITION_OFFSET, 0, { relativeTo: PADDLE_2_RELATIVE_TO, canvasSize: canvasSize });
        this.balls = [this.createBall(canvasSize.width / 2, canvasSize.height / 2)];

        //Create middle line
        this.middleLine = new LineDotted({
            x: 0,
            y: 0,
            posParam: {
                relativeTo: 'top-center',
                canvasSize: canvasSize
            },
            lenght: canvasSize.height,
            angle: Math.PI / 2,
            color: 'grey',
            lineWidth: LINE_DOTTED_WIDTH,
            dotLength: LINE_DOTTED_DOT_LENGTH,
            gapLength: LINE_DOTTED_GAP_LENGTH
        });

        //Create scoreboard
        this.scoreboard = new Scoreboard({
            x: 0,
            y: TEXT_MARGIN,
            posParam: {
                relativeTo: 'top-center',
                canvasSize: canvasSize
            },
            font: SCOREBOARD_FONT,
            color: SCOREBOARD_COLOR,
            gap: SCOREBOARD_GAP,
        });

        //Create players' avatars
        this.player1Avatar = new Avatar({
            x: PLAYER_AVATAR_POSITION.x,
            y: PLAYER_AVATAR_POSITION.y,
            posParam: {
                relativeTo: PLAYER_AVATAR_1_RELATIVE_TO,
                canvasSize: canvasSize,
                orientation: PLAYER_AVATAR_1_ORIENTATION
            },
            urlEncoded: this.player1AvatarUrlEncoded,
            size: PLAYER_AVATAR_SIZE
        });
        this.player2Avatar = new Avatar({
            x: PLAYER_AVATAR_POSITION.x,
            y: PLAYER_AVATAR_POSITION.y,
            posParam: {
                relativeTo: PLAYER_AVATAR_2_RELATIVE_TO,
                canvasSize: canvasSize,
                orientation: PLAYER_AVATAR_2_ORIENTATION
            },
            urlEncoded: this.player2AvatarUrlEncoded,
            size: PLAYER_AVATAR_SIZE
        });

        //Create players' names
        this.player1NameText = new Text({
            x: PLAYER_NAME_POSITION.x,
            y: PLAYER_NAME_POSITION.y,
            posParam: {
                relativeTo: PLAYER_NAME_1_RELATIVE_TO,
                canvasSize: canvasSize,
                orientation: PLAYER_NAME_1_ORIENTATION
            },
            font: PLAYER_NAME_FONT,
            color: PLAYER_NAME_COLOR,
            text: this.player1.getName()
        });
        this.player2NameText = new Text({
            x: PLAYER_NAME_POSITION.x,
            y: PLAYER_NAME_POSITION.y,
            posParam: {
                relativeTo: PLAYER_NAME_2_RELATIVE_TO,
                canvasSize: canvasSize,
                orientation: PLAYER_NAME_2_ORIENTATION
            },
            font: PLAYER_NAME_FONT,
            color: PLAYER_NAME_COLOR,
            text: this.player2.getName()
        });

        //Fallback store for end of game
        this.onEndedFunction = null;

        //Main loop setup
        MainLoop.setUpdate((dt) => {
            //Check for screen orientation change
            if (this.screenOrientation !== getScreenOrientation()) {
                this.screenOrientation = getScreenOrientation();
                //Reset paddles position relative to canvas
                this.paddle1.setPositionRelativeToCanvas(PADDLE_POSITION_OFFSET, 0, { relativeTo: PADDLE_1_RELATIVE_TO, canvasSize: this.getCanvasSize()});
                this.paddle2.setPositionRelativeToCanvas(PADDLE_POSITION_OFFSET, 0, {relativeTo: PADDLE_2_RELATIVE_TO, canvasSize: this.getCanvasSize()});
                this.middleLine.setPositionRelativeToCanvas(0, 0, { relativeTo: 'top-center', canvasSize: this.getCanvasSize() });
                this.player1Avatar.setPositionRelativeToCanvas(PLAYER_AVATAR_POSITION.x, PLAYER_AVATAR_POSITION.y, { relativeTo: PLAYER_AVATAR_1_RELATIVE_TO, canvasSize: this.getCanvasSize(), orientation: PLAYER_AVATAR_1_ORIENTATION });
                this.player2Avatar.setPositionRelativeToCanvas(PLAYER_AVATAR_POSITION.x, PLAYER_AVATAR_POSITION.y, { relativeTo: PLAYER_AVATAR_2_RELATIVE_TO, canvasSize: this.getCanvasSize(), orientation: PLAYER_AVATAR_2_ORIENTATION });
                this.player1NameText.setPositionRelativeToCanvas(PLAYER_NAME_POSITION.x, PLAYER_NAME_POSITION.y, { relativeTo: PLAYER_NAME_1_RELATIVE_TO, canvasSize: this.getCanvasSize(), orientation: PLAYER_NAME_1_ORIENTATION });
                this.player2NameText.setPositionRelativeToCanvas(PLAYER_NAME_POSITION.x, PLAYER_NAME_POSITION.y, { relativeTo: PLAYER_NAME_2_RELATIVE_TO, canvasSize: this.getCanvasSize(), orientation: PLAYER_NAME_2_ORIENTATION });
                this.scoreboard.setPositionRelativeToCanvas(0, TEXT_MARGIN, { relativeTo: 'top-center', canvasSize: this.getCanvasSize() });
            }
            //Get logical game dimensions (swap if portrait)
            const gameWidth = this.screenOrientation === "portrait" ? this.ctx.canvas.height : this.ctx.canvas.width;
            const gameHeight = this.screenOrientation === "portrait" ? this.ctx.canvas.width : this.ctx.canvas.height;

            //Keyboard input
            const paddleKeyboardMvt = this.getPaddleKeyboardMvt();

            //Touchscreen input
            const paddleTouchscreenMvt = this.getPaddleTouchscreenMvt();

            //Apply movement to paddles
            this.applyMvtToPaddle(this.paddle1, { keyboard: paddleKeyboardMvt.paddle1Mvt, touchscreen: paddleTouchscreenMvt.paddle1Position });
            this.applyMvtToPaddle(this.paddle2, { keyboard: paddleKeyboardMvt.paddle2Mvt, touchscreen: paddleTouchscreenMvt.paddle2Position });

            //Update paddles and ball position with logical dimensions
            this.updatePaddlesPosition(dt, gameWidth, gameHeight, this.paddle1, this.paddle2);
            this.updateBallsPosition(dt, gameWidth, gameHeight, this.balls);

            //Update scoreboard
            this.scoreboard.updateScore(this.player2.getScore(), this.player1.getScore());
        });

        //Draw loop setup
        MainLoop.setDraw(() => {
            //Update element relative to canvas size if needed
            this.updateElementPosRelativeToCanvas(
                this.middleLine, 
                this.scoreboard, 
                this.player1Avatar,
                this.player2Avatar,
                this.player1NameText, 
                this.player2NameText, 
                this.paddle1, 
                this.paddle2, 
                ...this.balls
            );

            //Update middle line length
            this.middleLine.lenght = this.ctx.canvas.height;

            //clear the canvas
            this.clearAndRefreshCanvas();

            //Rotate canvas if in portrait mode (width &lt; height)
            if (this.ctx.canvas.width &lt; this.ctx.canvas.height) {
                this.ctx.save();
                //Translate to center, rotate 90 degrees, then translate back
                this.ctx.rotate(Math.PI / 2);
                this.ctx.translate(0, -this.ctx.canvas.width);
            }

            //draw middle line
            this.middleLine.draw(this.ctx);

            //draw scoreboard
            this.scoreboard.draw(this.ctx);

            //draw players' avatars
            this.player1Avatar.draw(this.ctx);
            this.player2Avatar.draw(this.ctx);

            //draw players' names
            this.player1NameText.draw(this.ctx);
            this.player2NameText.draw(this.ctx);

            //draw paddles and ball
            this.paddle1.draw(this.ctx);
            this.paddle2.draw(this.ctx);
            for (let b of this.balls) {
                b.draw(this.ctx);
            }

            //Restore canvas state if rotated
            if (this.ctx.canvas.width &lt; this.ctx.canvas.height) {
                this.ctx.restore();
            }
        });

        //Manage panic situation when the update loop is taking too long
        MainLoop.setEnd((fps, panic) => {
            if (panic) {
                MainLoop.resetFrameDelta();
            }
        });
    }

    /**
     * Starts the game loop.
     * 
     * @method start
     */
    start() {
        MainLoop.start();
    }

    /**
     * Stops the game loop and cleans up input handlers.
     * Removes all keyboard and touchscreen event listeners to prevent
     * blocking interactions after the game ends.
     * 
     * @method stop
     */
    stop() {
        MainLoop.stop();
        
        // Clean up input handlers
        if (this.keyboard) {
            this.keyboard.destroy();
        }
        if (this.touchscreen) {
            this.touchscreen.destroy();
        }
    }

    /**
     * Sets a callback function to be executed when the game ends.
     * 
     * @method onEnded
     * @param {Function} callback - The function to call when the game ends
     */
    onEnded(callback) {
        this.onEndedFunction = callback;
    }

    /**
     * Creates a paddle (Rectangle) with specified position and parameters.
     * 
     * @method createPaddle
     * @param {number} x - The x-coordinate relative to the reference point
     * @param {number} y - The y-coordinate relative to the reference point
     * @param {Object} posParam - Position parameters for the paddle
     * @returns {Rectangle} A new paddle instance
     */
    createPaddle(x, y, posParam) {
        return new Rectangle({
            x: x,
            y: y,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
            mass: PADDLE_MASS,
            posParam: posParam,
        });
    }

    /**
     * Creates a ball (RectangleBouncy) with a random initial direction.
     * 
     * @method createBall
     * @param {number} x - The x-coordinate of the ball
     * @param {number} y - The y-coordinate of the ball
     * @returns {RectangleBouncy} A new ball instance
     */
    createBall(x, y) {
        return new RectangleBouncy({
            x: x,
            y: y,
            width: BALL_SIZE,
            height: BALL_SIZE,
            mass: BALL_MASS,
            speed: {
                velocity: BALL_SPEED,
                angle: parseInt(Math.random() * 2) * Math.PI + (Math.random()-0.5) * (Math.PI / 4), //Random angle towards left or right
            },
        });
    }

    /**
     * Clears and refreshes the canvas to match the current client dimensions.
     * 
     * @method clearAndRefreshCanvas
     */
    clearAndRefreshCanvas() {
        this.ctx.canvas.width = this.ctx.canvas.clientWidth;
        this.ctx.canvas.height = this.ctx.canvas.clientHeight;
    }

    /**
     * Gets the logical canvas dimensions, accounting for screen orientation.
     * Swaps width and height when in portrait mode.
     * 
     * @method getCanvasSize
     * @returns {Object} Object containing width and height properties
     */
    getCanvasSize() {
        return {
            width: this.screenOrientation === "portrait" ? this.ctx.canvas.height : this.ctx.canvas.width,
            height: this.screenOrientation === "portrait" ? this.ctx.canvas.width : this.ctx.canvas.height
        };
    }

    /**
     * Updates the positions of multiple canvas elements when the canvas size changes.
     * 
     * @method updateElementPosRelativeToCanvas
     * @param {...CanvasElement} elements - Variable number of canvas elements to update
     */
    updateElementPosRelativeToCanvas(...elements) {
        let dx, dy;
        if(this.screenOrientation === "portrait") {
            dx = (this.ctx.canvas.clientHeight - this.ctx.canvas.height);
            dy = (this.ctx.canvas.clientWidth - this.ctx.canvas.width);
        } else {
            dx = (this.ctx.canvas.clientWidth - this.ctx.canvas.width);
            dy = (this.ctx.canvas.clientHeight - this.ctx.canvas.height);
        }
        for (let element of elements) {
            element.updatePositionRelativeToCanvas(dx, dy);
        }
    }

    /**
     * Gets paddle movement input from keyboard, accounting for screen orientation.
     * 
     * @method getPaddleKeyboardMvt
     * @returns {Object} Object with paddle1Mvt and paddle2Mvt properties (-1: up, 1: down, 0: no movement)
     */
    getPaddleKeyboardMvt() {
        let paddle1Mvt = 0; // Movement for paddle 1 (-1: up, 1: down, 0: no movement)
        let paddle2Mvt = 0; // Movement for paddle 2 (-1: up, 1: down, 0: no movement)
        if(this.screenOrientation === "portrait") {
            //Keyboard input for paddle 2 (A/D keys)
            if (this.keyboard.isDown('KeyD')) paddle2Mvt = -1;
            else if (this.keyboard.isDown('KeyA')) paddle2Mvt = 1;
            //Keyboard input for paddle 1 (left/right arrows)
            if (this.keyboard.isDown('ArrowRight')) paddle1Mvt = -1;
            else if (this.keyboard.isDown('ArrowLeft')) paddle1Mvt = 1;
        } else {
            //Keyboard input for paddle 2 (W/S keys)
            if (this.keyboard.isDown('KeyW')) paddle2Mvt = -1;
            else if (this.keyboard.isDown('KeyS')) paddle2Mvt = 1;
            //Keyboard input for paddle 1 (up/down arrows)
            if (this.keyboard.isDown('ArrowUp')) paddle1Mvt = -1;
            else if (this.keyboard.isDown('ArrowDown')) paddle1Mvt = 1;
        }
        return {paddle1Mvt, paddle2Mvt};
    }

    /**
     * Gets paddle position input from touchscreen, accounting for screen orientation.
     * 
     * @method getPaddleTouchscreenMvt
     * @returns {Object} Object with paddle1Position and paddle2Position properties (pixel coordinates or undefined)
     */
    getPaddleTouchscreenMvt() {
        let paddle1Position;
        let paddle2Position;
        for (const touch of this.touchscreen.touches.values()) {
            if(this.screenOrientation === "portrait") {
                //Top side of the screen controls paddle 2
                if (touch.y &lt; window.innerHeight / 2 &amp;&amp; paddle2Position === undefined) {
                    paddle2Position = window.innerWidth - touch.x;
                } 
                //Bottom side of the screen controls paddle 1
                else if (touch.y >= window.innerHeight / 2 &amp;&amp; paddle1Position === undefined) {
                    paddle1Position = window.innerWidth - touch.x;
                }
                else {
                    break;
                }
            } else {
                //Left side of the screen controls paddle 2
                if (touch.x &lt; window.innerWidth / 2 &amp;&amp; paddle2Position === undefined) {
                    paddle2Position = touch.y;
                } 
                //Right side of the screen controls paddle 1
                else if (touch.x >= window.innerWidth / 2 &amp;&amp; paddle1Position === undefined) {
                    paddle1Position = touch.y;
                }
                else {
                    break;
                }
            }
        }
        return {paddle1Position, paddle2Position};
    }

    /**
     * Applies movement input to a paddle from either keyboard or touchscreen.
     * 
     * @method applyMvtToPaddle
     * @param {Rectangle} paddle - The paddle to move
     * @param {Object} mvt - Movement input object
     * @param {number} mvt.keyboard - Keyboard movement direction (-1, 0, or 1)
     * @param {number} [mvt.touchscreen] - Touchscreen position in pixels (optional)
     */
    applyMvtToPaddle(paddle, mvt) {
        if (mvt.keyboard !== 0) {
                paddle.setSpeed(0, mvt.keyboard * PADDLE_SPEED);
                paddle.applyForce(0, mvt.keyboard * PADDLE_ACCELERATION);
            } else if (mvt.touchscreen !== undefined) {
                paddle.y = mvt.touchscreen;
            } else {
                paddle.stop();
            }
    }

    /**
     * Updates paddle positions and handles canvas collision for both paddles.
     * 
     * @method updatePaddlesPosition
     * @param {number} dt - Delta time since last update
     * @param {number} gameWidth - Logical game width in pixels
     * @param {number} gameHeight - Logical game height in pixels
     */
    updatePaddlesPosition(dt, gameWidth, gameHeight) {
        for (let paddle of [this.paddle1, this.paddle2]) {
            paddle.move(dt);
            paddle.canvasCollision(gameWidth, gameHeight);
        }
    }

    /**
     * Updates ball positions, handles collisions, and manages scoring.
     * Removes balls that go off the left or right edges and awards points.
     * 
     * @method updateBallsPosition
     * @param {number} dt - Delta time since last update
     * @param {number} gameWidth - Logical game width in pixels
     * @param {number} gameHeight - Logical game height in pixels
     * @param {RectangleBouncy[]} balls - Array of ball instances to update
     */
    updateBallsPosition(dt, gameWidth, gameHeight, balls) {
        for (let i = 0; i &lt; balls.length; i++) {
            let ball = balls[i];
            ball.move(dt);
            const collisionSide = ball.canvasCollision(gameWidth, gameHeight);
            if(collisionSide &amp;&amp; (collisionSide === 'left' || collisionSide === 'right')) {
                // Remove array element
                balls.splice(i, 1);
                i--; // Adjust index after removal
                if(collisionSide === 'left') this.incrementPlayerScore(this.player1);
                else this.incrementPlayerScore(this.player2);
            }
            ball.rectangleCollision(this.paddle1, BALL_BOUNCINESS);
            ball.rectangleCollision(this.paddle2, BALL_BOUNCINESS);
        }
    }

    /**
     * Increments a player's score and checks for win condition.
     * If player reaches WIN_SCORE, ends the game. Otherwise, plays sound and spawns new ball.
     * 
     * @method incrementPlayerScore
     * @param {Player} player - The player whose score should be incremented
     */
    incrementPlayerScore(player) {
        player.incrementScore();
        if (player.getScore() >= WIN_SCORE) {
            this.endGame(player);
        } else {
            setTimeout(() => {
                // Reset ball to center after a score
                this.balls.push(this.createBall(
                    (this.paddle1.x + this.paddle2.x) / 2,
                    (this.paddle1.y + this.paddle2.y) / 2
                ));
            }, 2000);
            Audio.playWinPointSound();  
        }
    }

    /**
     * Ends the game, saves results to history, plays win sound, and calls the onEnded callback.
     * 
     * @method endGame
     */
    endGame() {
        this.stop();
        addGameResultToHistory(this.player1AvatarUrlEncoded, this.player1.getName(), this.player1.getScore(), this.player2AvatarUrlEncoded, this.player2.getName(), this.player2.getScore(), this.mode);
        Audio.playWinSound(this.onEndedFunction());
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-audio.html">audio</a></li><li><a href="module-clearHistory.html">clearHistory</a></li><li><a href="module-displayEndGame.html">displayEndGame</a></li><li><a href="module-displayGame.html">displayGame</a></li><li><a href="module-displayHistory.html">displayHistory</a></li><li><a href="module-displayNewGame.html">displayNewGame</a></li><li><a href="module-getAvatarUrlEncoded.html">getAvatarUrlEncoded</a></li><li><a href="module-getQueryParamsFromHash.html">getQueryParamsFromHash</a></li><li><a href="module-getScreenOrientation.html">getScreenOrientation</a></li><li><a href="module-setLocalStorageItem.html">setLocalStorageItem</a></li></ul><h3>Classes</h3><ul><li><a href="Avatar.html">Avatar</a></li><li><a href="CanvasElement.html">CanvasElement</a></li><li><a href="Keyboard.html">Keyboard</a></li><li><a href="LineDotted.html">LineDotted</a></li><li><a href="MainLoop.html">MainLoop</a></li><li><a href="Player.html">Player</a></li><li><a href="PongGame.html">PongGame</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleBouncy.html">RectangleBouncy</a></li><li><a href="Scoreboard.html">Scoreboard</a></li><li><a href="Text.html">Text</a></li><li><a href="Touchscreen.html">Touchscreen</a></li><li><a href="module.exports_module.exports.html">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addGameResultToHistory">addGameResultToHistory</a></li><li><a href="global.html#applyForce">applyForce</a></li><li><a href="global.html#applyMvtToPaddle">applyMvtToPaddle</a></li><li><a href="global.html#applySpeed">applySpeed</a></li><li><a href="global.html#atariAudioButton">atariAudioButton</a></li><li><a href="global.html#atariAudioLose">atariAudioLose</a></li><li><a href="global.html#atariAudioLosePoint">atariAudioLosePoint</a></li><li><a href="global.html#atariAudioPaddleHit">atariAudioPaddleHit</a></li><li><a href="global.html#atariAudioWin">atariAudioWin</a></li><li><a href="global.html#atariAudioWinPoint">atariAudioWinPoint</a></li><li><a href="global.html#avatarApiBaseUrl">avatarApiBaseUrl</a></li><li><a href="global.html#canvasCollision">canvasCollision</a></li><li><a href="global.html#clearAndRefreshCanvas">clearAndRefreshCanvas</a></li><li><a href="global.html#clearHistory">clearHistory</a></li><li><a href="global.html#createBall">createBall</a></li><li><a href="global.html#createPaddle">createPaddle</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#displayEndGame">displayEndGame</a></li><li><a href="global.html#displayGame">displayGame</a></li><li><a href="global.html#displayHistory">displayHistory</a></li><li><a href="global.html#displayNewGame">displayNewGame</a></li><li><a href="global.html#displaySection">displaySection</a></li><li><a href="global.html#distanceXto">distanceXto</a></li><li><a href="global.html#distanceYto">distanceYto</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#endGame">endGame</a></li><li><a href="global.html#form">form</a></li><li><a href="global.html#getAvatarUrl">getAvatarUrl</a></li><li><a href="global.html#getAvatarUrlEncoded">getAvatarUrlEncoded</a></li><li><a href="global.html#getCanvasSize">getCanvasSize</a></li><li><a href="global.html#getHistory">getHistory</a></li><li><a href="global.html#getLatestGame">getLatestGame</a></li><li><a href="global.html#getLocalStorageItem">getLocalStorageItem</a></li><li><a href="global.html#getName">getName</a></li><li><a href="global.html#getPaddleKeyboardMvt">getPaddleKeyboardMvt</a></li><li><a href="global.html#getPaddleTouchscreenMvt">getPaddleTouchscreenMvt</a></li><li><a href="global.html#getQueryParamsFromHash">getQueryParamsFromHash</a></li><li><a href="global.html#getScore">getScore</a></li><li><a href="global.html#getScreenOrientation">getScreenOrientation</a></li><li><a href="global.html#getSpeed">getSpeed</a></li><li><a href="global.html#history">history</a></li><li><a href="global.html#historyClearButton">historyClearButton</a></li><li><a href="global.html#historyListElement">historyListElement</a></li><li><a href="global.html#incrementPlayerScore">incrementPlayerScore</a></li><li><a href="global.html#incrementScore">incrementScore</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initializeHistory">initializeHistory</a></li><li><a href="global.html#isDown">isDown</a></li><li><a href="global.html#isInside">isInside</a></li><li><a href="global.html#move">move</a></li><li><a href="global.html#onEnded">onEnded</a></li><li><a href="global.html#playAgainButton">playAgainButton</a></li><li><a href="global.html#playOnce">playOnce</a></li><li><a href="global.html#player1Avatar">player1Avatar</a></li><li><a href="global.html#player1AvatarDefault">player1AvatarDefault</a></li><li><a href="global.html#player1AvatarElement">player1AvatarElement</a></li><li><a href="global.html#player1Input">player1Input</a></li><li><a href="global.html#player1UsernameElement">player1UsernameElement</a></li><li><a href="global.html#player2Avatar">player2Avatar</a></li><li><a href="global.html#player2AvatarDefault">player2AvatarDefault</a></li><li><a href="global.html#player2AvatarElement">player2AvatarElement</a></li><li><a href="global.html#player2Input">player2Input</a></li><li><a href="global.html#player2UsernameElement">player2UsernameElement</a></li><li><a href="global.html#pongGame">pongGame</a></li><li><a href="global.html#rectangleCollision">rectangleCollision</a></li><li><a href="global.html#resetScore">resetScore</a></li><li><a href="global.html#router">router</a></li><li><a href="global.html#saveHistory">saveHistory</a></li><li><a href="global.html#scoreElement">scoreElement</a></li><li><a href="global.html#screenOrientation">screenOrientation</a></li><li><a href="global.html#setForce">setForce</a></li><li><a href="global.html#setLocalStorageItem">setLocalStorageItem</a></li><li><a href="global.html#setPositionRelativeToCanvas">setPositionRelativeToCanvas</a></li><li><a href="global.html#setSpeed">setSpeed</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#title">title</a></li><li><a href="global.html#updateBallsPosition">updateBallsPosition</a></li><li><a href="global.html#updateElementPosRelativeToCanvas">updateElementPosRelativeToCanvas</a></li><li><a href="global.html#updatePaddlesPosition">updatePaddlesPosition</a></li><li><a href="global.html#updatePositionRelativeToCanvas">updatePositionRelativeToCanvas</a></li><li><a href="global.html#updateScore">updateScore</a></li><li><a href="global.html#updateSideScore">updateSideScore</a></li><li><a href="global.html#winnerTextElement">winnerTextElement</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Nov 27 2025 18:15:34 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
